<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Awarded Goods â€” 3D</title>
  <link rel="stylesheet" href="./style.css"/>
</head>
<body>
  <div id="ui">
    <div class="brand">Awarded Goods</div>
    <div class="nav">
      <button data-view="top">Top</button>
      <button data-view="bottom">Bottom</button>
      <button data-view="left">Left</button>
      <button data-view="right">Right</button>
      <button data-view="home" class="primary">Home</button>
    </div>
  </div>
  <canvas id="scene"></canvas>

  <!-- Three.js & helpers from CDN -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/OrbitControls.js';
    import { SVGLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/SVGLoader.js';
    import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

    // Renderer
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    // Scene & Camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 0, 8);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 3;
    controls.maxDistance = 20;

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambient);
    const key = new THREE.DirectionalLight(0xffffff, 2.0);
    key.position.set(5, 5, 5);
    scene.add(key);
    const rim = new THREE.SpotLight(0xffe6a8, 1.7, 0, Math.PI/6, 0.3, 1.5);
    rim.position.set(-6, 3, -4);
    rim.target.position.set(0, 0, 0);
    scene.add(rim, rim.target);

    // Galaxy background (stars)
    function createStarfield(count = 2500, radius = 80) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const r = radius * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        positions.set([x, y, z], i * 3);
      }
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 0.05, sizeAttenuation: true });
      const points = new THREE.Points(geom, mat);
      points.renderOrder = -1;
      return points;
    }
    const stars = createStarfield();
    scene.add(stars);

    // Background gradient plane
    const gradTex = new THREE.CanvasTexture((() => {
      const c = document.createElement('canvas');
      c.width = 2; c.height = 2;
      const ctx = c.getContext('2d');
      const grd = ctx.createLinearGradient(0,0,2,2);
      grd.addColorStop(0, '#0a0a1a');
      grd.addColorStop(1, '#1a0033');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,2,2);
      return c;
    })());
    gradTex.colorSpace = THREE.SRGBColorSpace;
    const bgPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshBasicMaterial({ map: gradTex, depthWrite: false })
    );
    bgPlane.position.set(0, 0, -50);
    scene.add(bgPlane);

    // Load & extrude SVG logo
    const group = new THREE.Group();
    scene.add(group);

    const gold = new THREE.MeshStandardMaterial({
      color: 0xd4af37,
      metalness: 1.0,
      roughness: 0.25
    });

    const loader = new SVGLoader();
    loader.load('./assets/logo.svg', (data) => {
      const shapes = [];
      data.paths.forEach((p) => {
        p.toShapes(true).forEach(s => shapes.push(s));
      });

      const extrudeSettings = {
        depth: 0.35,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.03,
        bevelSegments: 3,
        curveSegments: 12
      };

      const geometry = new THREE.ExtrudeGeometry(shapes, extrudeSettings);
      geometry.center();
      const mesh = new THREE.Mesh(geometry, gold);
      group.add(mesh);
      mesh.rotation.x = 0.1;
      mesh.rotation.y = -0.2;
    });

    // Camera view presets
    const views = {
      home: new THREE.Vector3(0, 0, 8),
      top:  new THREE.Vector3(0, 6, 0.01),
      bottom: new THREE.Vector3(0, -6, 0.01),
      left: new THREE.Vector3(-6, 0, 0.01),
      right: new THREE.Vector3(6, 0, 0.01)
    };

    function moveCameraTo(targetVec3, lookAt = new THREE.Vector3(0,0,0), duration = 900) {
      new TWEEN.Tween(camera.position)
        .to({ x: targetVec3.x, y: targetVec3.y, z: targetVec3.z }, duration)
        .easing(TWEEN.Easing.Cubic.InOut)
        .start();
      const start = { x: controls.target.x, y: controls.target.y, z: controls.target.z };
      new TWEEN.Tween(start)
        .to({ x: lookAt.x, y: lookAt.y, z: lookAt.z }, duration)
        .easing(TWEEN.Easing.Cubic.InOut)
        .onUpdate(() => controls.target.set(start.x, start.y, start.z))
        .start();
    }

    document.querySelectorAll('button[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        moveCameraTo(views[btn.dataset.view]);
      });
    });

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    function animate() {
      stars.rotation.y += 0.0008;
      TWEEN.update();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>